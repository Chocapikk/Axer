import socket
import requests
import dns.resolver
import concurrent.futures

from core.modular import Module
from data.logger import Logger

class Exploit(Module):

    def __init__(self):
        """
        Initialize an Exploit object with default attributes.

        The attributes 'name', 'description', 'author', and 'creation_date' are initialized
        with example values for demonstration purposes.
        """
        self.name           = "web-scan"
        self.description    = "Conduct a recon and vulnerability scan on a domain."
        self.author         = "oromos"
        self.creation_date  = "15-11-2023"

    def execute(self):
        """
        Placeholder method for the exploit's execution logic.

        Subclasses of Exploit must override this method to define the specific behavior
        of the exploit when executed. This method may return data or perform actions.
        """
        domain = "gsis.gr"
        Child.get_web_headers(domain)
        Child.get_web_service(domain)
        Child.get_dns_records(domain)
        Child.get_open_ports(domain)


class Log:

    def msg(status):
        Logger.__client_logger__(status, "logs.vs", "./logs/")


class Handler:

    @staticmethod
    def add_protocol(domain):
        if not domain.startswith('http://') and not domain.startswith('https://'):
            domain = 'https://' + domain  # Assume HTTPS if no protocol is specified
        return domain


class Child:

    @staticmethod
    def get_web_headers(domain):
        print("\n"+"█" * 52 + " WEB HEADERS " + "█" * 52 + "")
        domain = Handler.add_protocol(domain)
        response = requests.head(
            domain, 
            verify=True
        )

        header_info = response.headers
        for key, value in header_info.items():
            Log.msg(f"{key}: {value}")

    @staticmethod
    def get_web_service(domain):
        print("\n"+"█" * 52 + " WEB SERVICE " + "█" * 52 + "")
        domain = Handler.add_protocol(domain)
        response = requests.head(
            domain, 
            verify=True
        )

        header_info = response.headers.get('Server')
        Log.msg(f"WebService detected -> {header_info}")

    @staticmethod
    def get_dns_records(domain):
        print("\n" + "█" * 52 + " DNS RECORDS " + "█" * 52 + "")
        record_types = [
            'A', 
            'AAAA', 
            'CNAME', 
            'MX', 
            'NS', 
            'TXT', 
            'SOA'
        ]

        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(domain, record_type)
                for rdata in answers:
                    Log.msg(f"Record {record_type} -> {rdata}")
            except dns.resolver.NXDOMAIN:
                pass
            except dns.resolver.Timeout:
                Log.msg(f"Timeout on {record_type} for {domain}")
            except dns.resolver.NoAnswer:
                pass        

    @staticmethod
    def get_open_ports(domain):
        print("\n"+"█" * 48 + " AVAILABLE PORTS " + "█" * 52 + "")
        ports = range(1, 65500)
        try:
            domain = socket.gethostbyname(domain)
            # domain = Handler.add_protocol(domain)
            # domain = socket.gethostbyname(domain)
        except socket.gaierror:
            print('Invalid domain name.')
            sys.exit(1)

        def scan_port(port):
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(0.1)
                result = s.connect_ex((domain, port))

                if result == 0:
                    try:
                        service = socket.getservbyport(port)
                    except OSError:
                        service = 'unknown'
                    except socket.timeout:
                        pass
                    except ConnectionResetError:
                        pass
                    Log.msg(f"Found open port -> {port} using service -> {service}")

        with concurrent.futures.ThreadPoolExecutor() as executor:
            executor.map(scan_port, ports)
