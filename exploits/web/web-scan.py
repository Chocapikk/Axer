import ssl
import httpx
import whois
import socket
import asyncio
import requests
import sublist3r
import http.client
import urllib.parse
import dns.resolver
import concurrent.futures

from datetime import datetime
from data.logger import Logger
from core.modular import Module
from concurrent.futures import ThreadPoolExecutor


class Exploit(Module):
    """
    Exploit class for conducting recon and vulnerability scans on a domain.
    """

    def __init__(self):
        """
        Initialize an Exploit object with default attributes.

        The attributes 'name', 'description', 'author', and 'creation_date' are initialized
        with example values for demonstration purposes.
        """
        self.name = "web-scan"
        self.description = "Conduct a recon and vulnerability scan on a domain."
        self.author = "oromos"
        self.creation_date = "15-11-2023"

    def execute(self):
        """
        Placeholder method for the exploit's execution logic.

        Subclasses of Exploit must override this method to define the specific behavior
        of the exploit when executed. This method may return data or perform actions.
        """
        domain = input("domain [ex: google.com] -> ")
        Child.get_whois_information(domain)
        Child.get_ssl_certificate_info(domain)
        Child.get_web_headers(domain)
        Child.get_web_service(domain)
        Child.get_dns_records(domain)
        Child.get_open_ports(domain)
        Child.get_web_subdomains(domain)


class Log:
    """
    Log class for handling and displaying log messages.
    """

    def msg(status):
        """
        Log a message using the Logger class.

        Parameters:
        - status (str): The message to be logged.
        """
        Logger.__client_logger__(status, "logs.vs", "./logs/")


class Handler:
    """
    Handler class for handling various tasks related to domain and protocol manipulation.
    """

    @staticmethod
    def add_protocol(domain):
        """
        Add 'https://' protocol to a domain if no protocol is specified.

        Parameters:
        - domain (str): The domain to which the protocol is to be added.

        Returns:
        - str: The domain with the added protocol.
        """
        if not domain.startswith('http://') and not domain.startswith('https://'):
            domain = 'https://' + domain  # Assume HTTPS if no protocol is specified
        return domain

    def add_sub_protocol(domain, subdomain):
        """
        Add 'https://' protocol to a subdomain if no protocol is specified.

        Parameters:
        - domain (str): The main domain.
        - subdomain (str): The subdomain to which the protocol is to be added.

        Returns:
        - str: The subdomain with the added protocol.
        """
        if not subdomain.startswith('http://') and not subdomain.startswith('https://'):
            return f"https://{subdomain}.{domain}"
        else:
            return f"{subdomain}.{domain}"


class Child:
    """
    Child class containing various static methods for performing specific tasks.
    """

    @staticmethod
    def get_whois_information(domain):
        """
        Get WHOIS information for a domain.

        Parameters:
        - domain (str): The domain for which WHOIS information is to be retrieved.

        Returns:
        - dict: WHOIS information.
        """
        print("\n" + "█" * 46 + " WHOIS INFORMATION " + "█" * 52 + "")

        try:
            whois_info = whois.whois(domain)
            for key, value in whois_info.items():
                if key != 'status':
                    Log.msg(f"{key} -> {value}")
            return whois_info
        except whois.parser.PywhoisError as e:
            Log.msg(f"Error retrieving WHOIS information for {domain}: {e}")
            return None

    @staticmethod
    def get_ssl_certificate_info(domain):
        """
        Get SSL certificate information for a domain.

        Parameters:
        - domain (str): The domain for which SSL certificate information is to be retrieved.
        """
        Log.msg(f"\n\n" + "█" * 48 + f" SSL INFORMATION " + "█" * 52 + "")
        try:
            context = ssl.create_default_context()
            with context.wrap_socket(socket.socket(), server_hostname=domain) as ssock:
                ssock.connect((domain, 443))
                ssl_info = ssock.getpeercert()
                for key, value in ssl_info.items():
                    Log.msg(f"{key} -> {value}")
        except Exception as e:
            Log.msg(f"Error retrieving SSL certificate information for {domain}: {e}")

    @staticmethod
    def get_web_headers(domain):
        """
        Get web headers for a domain.

        Parameters:
        - domain (str): The domain for which web headers are to be retrieved.
        """
        print("\n"+"█" * 52 + " WEB HEADERS " + "█" * 52 + "")
        domain = Handler.add_protocol(domain)
        response = requests.head(
            domain, 
            verify=True
        )

        header_info = response.headers
        for key, value in header_info.items():
            Log.msg(f"{key}: {value}")

    @staticmethod
    def get_web_service(domain):
        """
        Get the web service information for a domain.

        Parameters:
        - domain (str): The domain for which web service information is to be retrieved.
        """
        print("\n"+"█" * 52 + " WEB SERVICE " + "█" * 52 + "")
        domain = Handler.add_protocol(domain)
        response = requests.head(
            domain, 
            verify=True
        )

        header_info = response.headers.get('Server')
        Log.msg(f"WebService detected -> {header_info}")

    @staticmethod
    def get_dns_records(domain):
        """
        Get DNS records for a domain.

        Parameters:
        - domain (str): The domain for which DNS records are to be retrieved.
        """
        print("\n" + "█" * 52 + " DNS RECORDS " + "█" * 52 + "")
        record_types = [
            'A', 
            'AAAA', 
            'CNAME', 
            'MX', 
            'NS', 
            'TXT', 
            'SOA'
        ]

        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(domain, record_type)
                for rdata in answers:
                    Log.msg(f"Record {record_type} -> {rdata}")
            except dns.resolver.NXDOMAIN:
                pass
            except dns.resolver.Timeout:
                pass
            except dns.resolver.NoAnswer:
                pass

    @staticmethod
    def fetch(subdomain, domain):
        """
        Fetch information for a subdomain.

        Parameters:
        - subdomain (str): The subdomain for which information is to be fetched.
        - domain (str): The main domain.
        """
        full_subdomain = Handler.add_sub_protocol(domain, subdomain)
        try:
            with httpx.Client() as client:
                response = client.get(full_subdomain)

                if response.status_code != 404:
                    if "CNAME" in response.text:
                        Log.msg(f"{response.status_code} -> {full_subdomain}")
                    else:
                        Log.msg(f"{response.status_code} -> {full_subdomain}")

        except httpx.RequestError as e:
            pass  # Handle request errors here if needed

    @staticmethod
    def get_web_subdomains(domain, wordlist_path="./dict/scanning/subdomains/subdomain_list.txt", max_workers=10):
        """
        Get web subdomains for a domain.

        Parameters:
        - domain (str): The domain for which web subdomains are to be retrieved.
        - wordlist_path (str): Path to the wordlist file containing subdomains.
        - max_workers (int): Maximum number of concurrent workers.
        """
        print("\n" + "█" * 48 + f" SUBDOMAINS SCAN " + "█" * 52 + "")
        try:
            with open(wordlist_path, 'r') as file:
                subdomains = [line.strip() for line in file.readlines()]

            if not subdomains:
                Log.msg("Subdomain list is empty.")
                return None

            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                executor.map(Child.fetch, subdomains, [domain] * len(subdomains))

            return subdomains
        except Exception as e:
            Log.msg(f"Error retrieving subdomains for {domain}: {e}")
            return None

    @staticmethod
    def get_open_ports(domain):
        """
        Get open ports for a domain.

        Parameters:
        - domain (str): The domain for which open ports are to be retrieved.
        """
        print("\n"+"█" * 48 + " AVAILABLE PORTS " + "█" * 52 + "")
        ports = range(1, 65500)
        try:
            domain = socket.gethostbyname(domain)
        except socket.gaierror:
            print('Invalid domain name.')
            sys.exit(1)

        def scan_port(port):
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(0.1)
                result = s.connect_ex((domain, port))

                if result == 0:
                    try:
                        service = socket.getservbyport(port)
                    except OSError:
                        service = 'unknown'
                    except socket.timeout:
                        pass
                    except ConnectionResetError:
                        pass
                    Log.msg(f"Found open port -> {port} using service -> {service}")

        with concurrent.futures.ThreadPoolExecutor() as executor:
            executor.map(scan_port, ports)
